{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(1783, 3)"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import nltk\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from nltk.stem import WordNetLemmatizer\n",
    "from nltk.corpus import wordnet\n",
    "import re, collections\n",
    "from collections import defaultdict\n",
    "from sklearn.feature_extraction.text import CountVectorizer\n",
    "from sklearn.metrics import mean_squared_error, r2_score\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.linear_model import LinearRegression, Ridge, Lasso\n",
    "from sklearn.svm import SVR\n",
    "from sklearn import ensemble\n",
    "from sklearn.model_selection import GridSearchCV\n",
    "from sklearn.metrics import cohen_kappa_score\n",
    "import enchant \n",
    "import pandas as pd\n",
    "import spacy\n",
    "import re\n",
    "from nltk import word_tokenize\n",
    "from nltk.tokenize import RegexpTokenizer\n",
    "import urllib.request\n",
    "\n",
    "dataframe = pd.read_csv('training_set_rel3.tsv', encoding = 'latin-1',sep='\\t')\n",
    "dataframe = dataframe[['essay_id','essay_set','essay','domain1_score']]\n",
    "\n",
    "dataframe = dataframe[(dataframe['essay_set'] == 1)]\n",
    "dataframe.dropna(axis=1, how='all', inplace=True)\n",
    "\n",
    "dataframe.set_index('essay_id',inplace=True, drop=True)\n",
    "\n",
    "dataframe.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "countdown = 0\n",
    "def get_string_arrays(regExTokenizer, df):\n",
    "    array_of_strings = []\n",
    "    for essay in df['essay']:\n",
    "        words = regExTokenizer.tokenize(essay)\n",
    "        array = []\n",
    "        size = len(words)//4\n",
    "        curr = 0\n",
    "        flag = 0\n",
    "        while flag == 0:\n",
    "            new = ' '\n",
    "            for i in range(curr,curr+size):\n",
    "                if i==len(words):\n",
    "                    flag = 1\n",
    "                    break\n",
    "                new = new+' '+words[i]\n",
    "            curr+=10\n",
    "            array.append(new)\n",
    "        array_of_strings.append(array)\n",
    "    return array_of_strings\n",
    "array_of_strings = get_string_arrays(tokenizer,dataframe)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "tfidfvectorizer = TfidfVectorizer(analyzer='word',stop_words= 'english')\n",
    "cosine_array = []\n",
    "for i in range(0,len(array_of_strings)):\n",
    "    tfidf_wm = tfidfvectorizer.fit_transform(array_of_strings[i])\n",
    "    similarity_matrix = cosine_similarity(tfidf_wm)\n",
    "    cosine_array.append(similarity_matrix)\n",
    "    \n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "def get_avg_distance_bw_neighbours(cosine_array):\n",
    "    array = []\n",
    "    for i in range(0,len(cosine_array)):\n",
    "        j = 0\n",
    "        dist = 0\n",
    "        while j < cosine_array[i].shape[0]-1:\n",
    "            dist+=cosine_array[i][j][j+1]\n",
    "            j+=1\n",
    "        array.append(dist/(cosine_array[i].shape[0]-1))\n",
    "    return array\n",
    "avg_distance_bw_neighbours = get_avg_distance_bw_neighbours(cosine_array)\n",
    "dataframe.assign(avg_distance_bw_neighbours=avg_distance_bw_neighbours)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "def get_maxmin_distance_bw_neighbours(cosine_array):\n",
    "    maxarray = []\n",
    "    minarray = []\n",
    "    for i in range(0,len(cosine_array)):\n",
    "        j = 0\n",
    "        maxn = 0\n",
    "        minn = 1\n",
    "        while j < cosine_array[i].shape[0]-1:\n",
    "            maxn = maxn if maxn > cosine_array[i][j][j+1] else cosine_array[i][j][j+1]\n",
    "            minn = minn if minn < cosine_array[i][j][j+1] else cosine_array[i][j][j+1]\n",
    "            j+=1\n",
    "        maxarray.append(maxn)\n",
    "        minarray.append(minn)\n",
    "    return maxarray,minarray\n",
    "max_distance_bw_neighbours,min_distance_bw_neighbours = get_maxmin_distance_bw_neighbours(cosine_array)\n",
    "dataframe.assign(max_distance_bw_neighbours=max_distance_bw_neighbours)\n",
    "dataframe.assign(min_distance_bw_neighbours=min_distance_bw_neighbours)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "def get_avg_distance_bw_points(cosine_array):\n",
    "    array = []\n",
    "    for i in range(0,len(cosine_array)):\n",
    "        dist = 0\n",
    "        for j in range(0,cosine_array[i].shape[0]):\n",
    "            for k in range(0,cosine_array[i].shape[1]):\n",
    "                dist+=cosine_array[i][j][k]\n",
    "        array.append(dist/(cosine_array[i].shape[0]*cosine_array[i].shape[1]))\n",
    "    return array\n",
    "avg_distance_bw_points = get_avg_distance_bw_points(cosine_array)\n",
    "dataframe.assign(avg_distance_bw_points=avg_distance_bw_points)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "def get_max_distance_bw_points(cosine_array):\n",
    "    array = []\n",
    "    for i in range(0,len(cosine_array)):\n",
    "        maxn = 0\n",
    "        for j in range(0,cosine_array[i].shape[0]):\n",
    "            for k in range(0,cosine_array[i].shape[1]):\n",
    "                if j!=k:\n",
    "                    maxn = cosine_array[i][j][k] if maxn < cosine_array[i][j][k] else maxn\n",
    "        array.append(maxn)\n",
    "    return array\n",
    "max_distance_bw_points = get_max_distance_bw_points(cosine_array)\n",
    "dataframe.assign(max_distance_bw_points=max_distance_bw_points)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "def get_clark_and_evans(cosine_array):\n",
    "    array = []\n",
    "    for i in range(0,len(cosine_array)):\n",
    "        dist = 0\n",
    "        for j in range(0,cosine_array[i].shape[0]):\n",
    "            curr = 1\n",
    "            if j-1>=0 and cosine_array[i][j-1][j] < curr :\n",
    "                curr = cosine_array[i][j-1][j]\n",
    "            if j+1<cosine_array[i].shape[0] and cosine_array[i][j][j+1] < curr:\n",
    "                curr = cosine_array[i][j][j+1]\n",
    "            dist+=curr\n",
    "        array.append(2*dist/math.sqrt(cosine_array[i].shape[0]))\n",
    "    return array\n",
    "clark_and_evans = get_clark_and_evans(cosine_array)\n",
    "dataframe.assign(clark_and_evans=clark_and_evans)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "def get_avg_distance_to_nearest_neighbours(cosine_array):\n",
    "    array = []\n",
    "    for i in range(0,len(cosine_array)):\n",
    "        dist = 0\n",
    "        for j in range(0,cosine_array[i].shape[0]):\n",
    "            curr = 1\n",
    "            if j-1>=0 and cosine_array[i][j-1][j] < curr :\n",
    "                curr = cosine_array[i][j-1][j]\n",
    "            if j+1<cosine_array[i].shape[0] and cosine_array[i][j][j+1] < curr:\n",
    "                curr = cosine_array[i][j][j+1]\n",
    "            dist+=curr\n",
    "        array.append(dist/cosine_array[i].shape[0])\n",
    "    return array\n",
    "avg_distance_to_nearest_neighbours = get_avg_distance_to_nearest_neighbours(cosine_array)\n",
    "dataframe.assign(avg_distance_to_nearest_neighbours=avg_distance_to_nearest_neighbours)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "def get_cumulative_frequency_distribution(cosine_array):\n",
    "    array = []\n",
    "    for i in range(0,len(cosine_array)):\n",
    "        dist = 0\n",
    "        for j in range(0,cosine_array[i].shape[0]):\n",
    "            curr = 1\n",
    "            if j-1>=0 and cosine_array[i][j-1][j] < curr :\n",
    "                curr = cosine_array[i][j-1][j]\n",
    "            if j+1<cosine_array[i].shape[0] and cosine_array[i][j][j+1] < curr :\n",
    "                curr = cosine_array[i][j][j+1]\n",
    "            if curr <= avg_distance_to_nearest_neighbours[i] :\n",
    "                dist+=1\n",
    "        array.append(dist/cosine_array[i].shape[0])\n",
    "    return array\n",
    "cumulative_frequency_distribution = get_cumulative_frequency_distribution(cosine_array)\n",
    "dataframe.assign(cumulative_frequency_distribution=cumulative_frequency_distribution)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "euclidean_array = []\n",
    "for i in range(0,len(array_of_strings)):\n",
    "    tfidf_wm = tfidfvectorizer.fit_transform(array_of_strings[i])\n",
    "    similarity_matrix = euclidean_distances(tfidf_wm)\n",
    "    euclidean_array.append(similarity_matrix)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "avg_distance_bw_neighbours_euclid = get_avg_distance_bw_neighbours(euclidean_array)\n",
    "dataframe.assign(avg_distance_bw_neighbours_euclid=avg_distance_bw_neighbours_euclid)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "max_distance_bw_neighbours_euclid,min_distance_bw_neighbours_euclid = get_maxmin_distance_bw_neighbours(euclidean_array)\n",
    "dataframe.assign(max_distance_bw_neighbours_euclid=max_distance_bw_neighbours_euclid)\n",
    "dataframe.assign(min_distance_bw_neighbours_euclid=min_distance_bw_neighbours_euclid)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "avg_distance_bw_points_euclid = get_avg_distance_bw_points(euclidean_array)\n",
    "dataframe.assign(avg_distance_bw_points_euclid=avg_distance_bw_points_euclid)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "centroid_array = []\n",
    "for i in range(0,len(array_of_strings)):\n",
    "    tfidf_wm = tfidfvectorizer.fit_transform(array_of_strings[i])\n",
    "    temp = tfidf_wm[0]\n",
    "    for j in range(1,tfidf_wm.shape[0]):\n",
    "        temp+=tfidf_wm[j]\n",
    "    centroid_array.append(temp/tfidf_wm.shape[0])\n",
    "    \n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "euclidcentroid_array = []\n",
    "for i in range(0,len(array_of_strings)):\n",
    "    tfidf_wm = tfidfvectorizer.fit_transform(array_of_strings[i])\n",
    "    similarity_matrix = euclidean_distances(tfidf_wm,centroid_array[i])\n",
    "    euclidcentroid_array.append(similarity_matrix)\n",
    "    \n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "def get_avg_distance_bw_centroid_and_points(euclidcentroid_array):\n",
    "    array = []\n",
    "    for i in range(0,len(euclidcentroid_array)):\n",
    "        dist = 0\n",
    "        for j in range(0,len(euclidcentroid_array[i])):\n",
    "            dist+=euclidcentroid_array[i][j]\n",
    "        array.append(dist/len(euclidcentroid_array[i]))\n",
    "    return array\n",
    "avg_distance_bw_centroid_and_points = get_avg_distance_bw_centroid_and_points(euclidcentroid_array)\n",
    "dataframe.assign(avg_distance_bw_centroid_and_points=avg_distance_bw_centroid_and_points)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "def get_maxmin_distance_bw_centroid_and_points(euclidcentroid_array):\n",
    "    maxarray = []\n",
    "    minarray = []\n",
    "    for i in range(0,len(euclidcentroid_array)):\n",
    "        mx = 0\n",
    "        mn = 1000\n",
    "        for j in range(0,len(euclidcentroid_array[i])):\n",
    "            if mx < euclidcentroid_array[i][j]:\n",
    "                mx = euclidcentroid_array[i][j]\n",
    "            if mn > euclidcentroid_array[i][j]:\n",
    "                mn = euclidcentroid_array[i][j]\n",
    "        maxarray.append(mx)\n",
    "        minarray.append(mn)\n",
    "    return maxarray,minarray\n",
    "max_distance_bw_centroid_and_points,min_distance_bw_centroid_and_points = get_maxmin_distance_bw_centroid_and_points(euclidcentroid_array)\n",
    "dataframe.assign(max_distance_bw_centroid_and_points=max_distance_bw_centroid_and_points)\n",
    "dataframe.assign(min_distance_bw_centroid_and_points=min_distance_bw_centroid_and_points)\n",
    "\n",
    "print(countdown)\n",
    "countdown+=1\n",
    "\n",
    "\n",
    "dataframe.to_csv(\"CoherenceFeaturesSet1.csv\",index=False)\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
